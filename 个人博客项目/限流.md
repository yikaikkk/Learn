# 限流
博客中的限流用的是一种静态限流的方式，采用限制一定时间内固定ip的访问次数来控制流量

## 限流策略
项目采用的是计数器算法，通过Redis的原子递增操作实现时间窗口内的请求计数。

限流键的生成采用以下格式：

IP地址-方法名

例如：

用户IP为192.168.1.100调用sendCode方法，生成的键为：
192.168.1.100-sendCode

项目中目前有两个接口配置了限流：评论接口和验证码发送接口

## 具体实现

```java
@Override
public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
    if (handler instanceof HandlerMethod) {
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        AccessLimit accessLimit = handlerMethod.getMethodAnnotation(AccessLimit.class);
        if (accessLimit != null) {
            long seconds = accessLimit.seconds();
            int maxCount = accessLimit.maxCount();
            // 构造Redis键：IP地址 + 方法名
            String key = IpUtil.getIpAddress(httpServletRequest) + "-" + handlerMethod.getMethod().getName();
            try {
                // 原子递增并设置过期时间
                long q = redisService.incrExpire(key, seconds);
                if (q > maxCount) {
                    // 超过限流阈值，拒绝请求
                    render(httpServletResponse, ResultVO.fail("请求过于频繁，" + seconds + "秒后再试"));
                    log.warn(key + "请求次数超过每" + seconds + "秒" + maxCount + "次");
                    return false;
                }
                return true;
            } catch (RedisConnectionFailureException e) {
                log.warn("redis错误: " + e.getMessage());
                return false;
            }
        }
    }
    return true;
}

@Override
public Long incrExpire(String key, long time) {
    // 原子递增操作
    Long count = redisTemplate.opsForValue().increment(key, 1);
    // 如果是第一次访问（计数为1），则设置过期时间
    if (count != null && count == 1) {
        redisTemplate.expire(key, time, TimeUnit.SECONDS);
    }
    return count;
}
```

## 一些其他限流方式
### 令牌桶
令牌桶算法之前提到过：http://115.190.50.228:8083/articles/159 其中提到过利用redis实现令牌桶限流

### 滑动窗口限流

将时间划分为多个区间

在每个区间内每有一次请求就讲计数器加1维持一个时间窗口，占据多个区间

每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间

若当前的窗口内区间的请求总数和超过了限制数量，则本窗口内的请求都被丢弃
