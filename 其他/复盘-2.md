# 项目复盘-Clickhouse-part1

##  背景
在上一次的复盘中，提到kafka中的数据会到不同的地方。
## clickhouse集群
### ReplicatedMergeTree 
----
### 副本

在clickhouse中最主要的引擎是mergeTree，而在该项目中使用的ReplicatedMergeTree 引擎，这个引擎通过副本机制在多个节点上保存副本，当一个节点宕机以后，可以通过别的副本进行访问。

### 自动同步
在使用ReplicatedMergeTree 引擎创建表时，会在zookeeper上创建一个元数据。协同步骤如下，
1. 元数据管理


    当创建一个 ReplicatedMergeTree 表时，ClickHouse 会在 ZooKeeper 中为该表创建一个专门的目录，用于存储其元数据。该目录包含以下关键信息：

    副本注册：每个副本都会在该目录下创建一个临时节点来注册自己。这使得集群中的所有副本都能感知彼此的存在。

    表结构信息：所有副本的表结构都必须一致。ZooKeeper 确保了表结构变更 (DDL 操作) 在所有副本上得到同步。
数据块的元数据：每个数据块 (data part) 的元数据，如校验和，也会被记录在 ZooKeeper 中，用于数据同步和去重。 

2. 异步数据复制


    数据复制是多主异步模式，任何副本都可以接收写操作 (INSERT)。ZooKeeper 在此过程中扮演着协调者的角色。 

插入数据的流程：

    写入本地：当一个 INSERT 请求发送到某个副本时，该副本首先将数据写入其本地的 ReplicatedMergeTree 表中，形成一个新的数据块。

    记录日志：写入本地后，该副本会向 ZooKeeper 写入一条复制日志 (replication log) 条目，记录新生成的数据块信息。

    其他副本同步：集群中的其他副本会监控 ZooKeeper 中的复制日志。当它们检测到有新的日志条目时，就会主动从写入数据的副本或其他已同步的副本那里，下载缺失的数据块并进行同步。 

3. 合并任务协调

    MergeTree 引擎会定期合并数据块，以优化存储和查询性能。在复制环境中，合并操作也需要协调，以防止不同副本执行重复或冲突的合并任务。

合并操作的流程：

    提交合并：当一个副本决定执行合并操作时，它会先在 ZooKeeper 中声明此意图。

    锁定合并：如果成功，其他副本就会知道这个合并任务正在进行，从而避免重复执行相同的合并。

    通知结果：合并完成后，发起者会在 ZooKeeper 中更新状态。其他副本将看到最终合并后的数据块，并选择下载或等待

### 高可用和水平拓展的实现
在集群中，为了提高数据查询的效率，并且实现水平拓展，在创建表时，主要使用的是分布式表。在使用分布式表和ReplicatedMergeTree引擎的结合可以实现高可用和水平拓展

#### 分布式表+ReplicatedMergeTree
Distributed 表本身不存储数据，而是作为一个查询路由层（路由器），
将读写请求分发到多个后端的本地表上（通常是 MergeTree 或 ReplicatedMergeTree）。

分布式表的核心功能如下
| 功能 | 描述 |
|------|------|
| 数据路由 | 按分片规则将写入分发到不同节点 |
| 查询分发 | 自动将查询并行发送到所有分片节点 |
| 结果聚合 | 从各分片节点收集结果并在发起端汇总 |
| 负载均衡 | 支持随机分发或一致性哈希分发 |
| 高可用支持 | 可配置多个副本节点自动容错 |

在执行一条sql语句时，分布式表会执行以下操作：

	1.	Distributed 表根据分片键（如 cityHash64(user_id)）计算出目标分片；

	2.	将这条数据发送给该分片中的某个副本；

	3.	该副本的本地表（events_local）实际写入数据；

	4.	如果该分片是 ReplicatedMergeTree，其他副本会自动从 ZooKeeper 同步这条数据。


### 技术选型
最后，在不同方面对比一下mysql和clickhouse
| 对比项 | MySQL | ClickHouse |
|--------|--------|-------------|
| **定位** | 事务型数据库（OLTP） | 分析型数据库（OLAP） |
| **数据存储方式** | 行存储（Row Store） | 列存储（Column Store） |
| **典型应用场景** | 业务系统、用户信息、订单交易等 | 日志分析、指标统计、数据仓库、报表系统 |
| **写入性能** | 较强，支持高并发事务写入 | 批量写入性能强，单条写入性能较弱 |
| **查询性能** | 适合点查、少量行的查询 | 适合扫描大量数据、聚合、排序、统计 |
| **事务支持** | 完整的 ACID 支持 | 不支持复杂事务（仅部分原子性保证） |
| **索引机制** | B+ 树索引、全文索引、哈希索引等 | 稀疏索引（Sparse Index）+ 数据分区（Partition） |
| **数据更新** | 支持实时更新、删除 | 更新会生成新的数据 part（写放大） |
| **分布式能力** | 原生支持有限（主从/分片需中间件） | 原生支持分布式与副本机制（Distributed + ReplicatedMergeTree） |
| **高可用机制** | 主从复制、MGR、Proxy | ReplicatedMergeTree + ZooKeeper（或 ClickHouse Keeper） |
| **扩展性** | 垂直扩展为主（Scale Up） | 水平扩展为主（Scale Out） |
| **存储压缩** | 普通压缩比（约 2–3x） | 列式高压缩比（可达 5–10x） |
| **JOIN 支持** | 强大、支持多表复杂 JOIN | 支持但成本高，推荐使用预聚合或分布式 JOIN |
| **实时性** | 实时性强 | 近实时（适合分钟级或秒级延迟） |
| **主键约束** | 强制唯一 | 主键仅用于排序，不保证唯一 |
| **删除操作** | 即时生效 | 逻辑删除（后台合并时清理） |
| **聚合性能** | 普通 | 极快（向量化 + 列式计算） |
| **适合数据规模** | 百万到千万级 | 亿级到万亿级数据量 |
| **依赖组件** | 无（单机即可） | ZooKeeper / ClickHouse Keeper（副本同步） |
| **典型使用场景** | Web 应用、交易系统、后台管理 | 日志分析、监控系统、埋点分析、BI 报表 |
| **代表性引擎** | InnoDB, MyISAM | MergeTree, ReplicatedMergeTree, Distributed |


在日志分析的场景下，对于事务的需求不高，但是对于大数据量插入和删除的需求巨大，在OLAP场景下，clickhouse的实用性更高