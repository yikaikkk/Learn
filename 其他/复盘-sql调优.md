# 复盘-sql调优

## 背景
负责的项目是需要一个实时且有一定性能要求的项目，目前部分接口QPS在6000左右，因此对于sql执行的性能有一定要求

## sql调优方向
1、索引

加索引是最常见的优化方式，使用索引可以避免全表扫描，建立索引时在常用的列上创建索引，可以减少回表的次数，从而加快查询速度

2、慢sql排查

当一个sql执行时间过长，可以使用explain来查看sql执行，或者查看慢查询log

```
system  > const > eq_ref > ref  > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
system： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。
const：表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。
eq_ref：查询时命中主键primary key 或者 unique key索引， type 就是 eq_ref。
ref：区别于eq_ref ，ref表示使用非唯一性索引，会找到很多个符合条件的行。
ref_or_null：这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。
index_merge：使用了索引合并优化方法，查询使用了两个以上的索引
unique_subquery：替换下面的 IN子查询，子查询返回不重复的集合
index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。
range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用 bettween...and、<、>、<=、in 等条件查询 type 都是 range。
index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。
ALL：将遍历全表以找到匹配的行，性能最差。

```

3、避免索引失效

常见的索引失效有 `对索引使用左或者左右模糊匹配`,`对索引使用函数`,`对索引进行表达式计算`,`对索引隐式类型转换`,`联合索引非最左匹配`,`WHERE 子句中的 OR`这些都会导致索引失效，从而导致全表扫描

4、 union all替换union

使用union时会进行去重，而使用union all会直接合并，从而提高效率

5、减少查询字段

在使用select是，减少使用select *，尽量使用select具体字段，减少返回的数据量

6、减少sql使用

对于多个相同格式的sql，比如多个insert，采用单个sql批量执行

7、联表优化

对于不可避免的联表查询，尽量使用小表驱动大表。

8、避免大事务

在遇到大事务时，容易造成数据库死锁等问题，可以通过死锁日志来判断是否存在死锁


## mysql集群方面

1、读写分离

使用读写分离，减少写节点的压力

2、监控mysql集群健康度

在最近工作中的mysql使用情况来看，当mysql集群的cpu占用率达到50%以上时就会导致mysql的主从不一致问题，同时查询速度也会变慢。

3、分库分表

当单表的数量过大时，在对表就行变更时也会出现性能问题，所以可以采用分库分表的方式来处理单表资源过大的问题。