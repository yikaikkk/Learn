# mysql 死锁

## 背景
在之前的一次开发中，遇到了一次数据库死锁

## 过程
通过mysql的show innodb engine status 命令，查看了mysql的引擎监控日志，发现出现了数据库死锁问题。

问题是有两个事务在更新同一张表时，两个事务对于表中数据的读取顺序不一样，所以导致在事务A读取到74行时，这一行的锁在事务B中，而事务A在试图获取56行的锁时，锁已经被B获取到，所以导致死锁

## 解决方式

从日志来看，查看数据库自身的处理，mysql自身将小事务进行会滚了，从而消除了死锁

后续减少了事务的维持时间，将大事务改为小事务，从而避免死锁的出现

## 预防措施

1. 维持一致的锁定顺序
确保所有事务都以相同的顺序获取锁。这可以减少锁定冲突的可能性，因为事务不会因为等待其他事务释放锁而相互阻塞。

例如，如果有多个表或资源需要锁定，总是按照相同的顺序（如字典顺序）锁定这些资源。

2. 使用最小的锁粒度
尽量使用行级锁而不是表级锁。

行级锁允许更高的并发，因为它仅锁定需要修改或查询的数据行，而不是整个表。这样，即使多个事务操作同一表，它们也可能操作不同的行，从而减少死锁的风险。

3. 减少事务持续时间
尽量缩短事务的执行时间。

长事务占用锁的时间越长，与其他事务发生冲突的可能性就越大。你可以通过优化查询语句和减少事务中的操作数来减少事务持续时间。

4. 使用锁超时
在某些数据库管理系统中，可以设置锁的超时时间。

这意味着事务在等待锁超过设定的时间后将自动回滚。这不仅可以防止死锁，还可以避免一个事务无限期地等待资源。

5. 死锁检测和回滚
启用数据库的死锁检测功能，让数据库管理系统能够自动检测死锁并回滚某个事务来解锁。

这通常是最后的手段，因为它可能导致数据不一致的问题。应当只在其他方法都无法实现时使用。

6. 避免不必要的锁
审查和优化事务逻辑，确保只锁定必要的资源。

例如，如果事务只读取数据而不进行修改，可以考虑使用非锁定读（例如，在MySQL中使用SELECT ... WITH (NOLOCK)）。

7. 使用乐观并发控制
在一些场景中，使用乐观并发控制（OCC）而不是悲观锁定可能更合适。OCC通过在事务提交时检查数据是否已被其他事务修改来避免锁定，适用于读多写少的场景。

8. 避免无索引行锁升级为表锁
尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁