# Kafka和rabbitmq

## 背景
在一个项目中，使用的消息队列是kafka。在自己的博客项目中选择了另一种消息队列，rabbitmq。这里具体分析一下两种消息队列的使用场景和各自的特点

## 特性对比

|特性|Kafka|RabbitMQ|
|----|-----|------|
|消息模型|Topic + Partition（发布/订阅）|Queue（点对点或发布/订阅）
|吞吐量|极高，百万级消息/秒|较低，中小规模消息为主
|消息持久化|默认持久化到磁盘，可配置保留时间|可持久化，但默认偏内存
|消费模式|Consumer Group 并行消费，顺序保证在 Partition 内|消费者拉取或推送，顺序保证靠 Queue
|扩展性|水平扩展简单，通过 Partition + Broker|水平扩展有限，需要 Federation/Cluster
|消息顺序|Partition 内保证顺序|Queue 内顺序保证
|消息确认机制|Offset 管理（Consumer 控制提交）|ACK/NACK 消息确认
|消息重试/补偿|可以重新消费历史消息|一般通过死信队列处理

## 选型分析
日志系统选择kafka：

	1.	高吞吐量
	•	日志量非常大，可能是每秒几万到几百万条，RabbitMQ 在这种场景下容易成为瓶颈。kafka相比于rabbitmq，可以支撑更高的吞吐量。
	2.	顺序性和可回溯
	•	Kafka 的 Partition 保证顺序，并且消息可以保留一段时间，方便 重放 或 离线处理。
	•	日志系统经常需要重跑历史数据，比如数据统计、报表。kafka支持重复消费。
	3.	水平扩展容易
	•	可以通过增加 Partition + Broker，轻松支撑日志量增长。
	4.	消费灵活
	•	多个下游系统（比如统计系统、搜索引擎、实时告警系统）可以独立消费同一 Topic，而不影响其他消费者。

博客选择rabbitmq的原因

	1.	消息量不大
	•	在博客系统的消息通常是评论通知、点赞通知、邮件推送，并发量远低于日志系统，不需要 Kafka 的高吞吐量。
	2.	消息处理及时性高
	•	RabbitMQ 适合 低延迟的即时处理，消息产生后立刻被消费者处理（推送模式）。
	3.	顺序要求简单
	•	消息顺序要求不高，或者可以通过单队列保证。Kafka 的分区机制反而增加复杂度。
	4.	易用性和功能丰富
	•	RabbitMQ 支持 复杂路由、Topic Exchange、延时队列、死信队列 等功能，适合业务逻辑驱动的消息处理。
	•	Kafka 的路由主要靠 Partition Key，灵活性不如 RabbitMQ。


## Kafka为什么快

### partion机制
1、并行机制

 在kafka中，一个Topic可以被分为多个partion，这些partion可以位于不同的机器，所以可以并行处理，提高速度。

2、磁盘顺序写

 kafka中的每个分区都是有序的，新的消息是在后面追加，所以是顺序写，顺序写在磁盘中会比随机写的效率更高。而在清除旧数据时，在kafka中，每个partion会被分为不同的segment段，删除时就直接删除对应的segment。

3、pagecache

 当 Producer 写消息到 Kafka Partition 时，Kafka 会把消息写到 日志文件（log segment），操作系统会把这些文件缓存在 PageCache 中，后续再将其刷入到磁盘，可以有效的减少IO次数。

 当 Consumer 读取消息时，操作系统首先从 PageCache 中读取，如果命中缓存，就不需要真正的磁盘IO。

4、零拷贝

  一般读取需要先从磁盘读到内核态，再从内核态读到用户态，在用户态完成拷贝，在复制到内核态，在通过网卡发送。而kafka利用零拷贝可以跳过用户态复制，直接在内核态完成发送，减少了状态转换带来的开销

5、批处理
  
  在kafka中，每次网络io并不是有一条消息就发送，而是对一批消息进行处理，减少了IO带来的损耗