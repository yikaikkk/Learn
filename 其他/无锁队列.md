# 无锁队列

## 背景
最近在一个项目中，有一个场景是一个多生产者单消费者的场景，在在这个场景中，会有多个线程往一个队列中写入数据，由于这是一个端上的应用，所以在性能上有一定要求，加锁的话，会导致多个线程的大量竞争。

## 无锁队列
无锁队列是生产者消费者模型常用的一种实现方式。无锁队列的无锁是指线程不会因为锁而阻塞（sleep），即使发生竞争，系统也保证至少一个线程可以继续推进（整体不会卡死）。

无锁队列核心要点：

	•	不使用 mutex
	•	不使用条件变量
	•	全靠 原子操作（atomic）

特别是 CAS（Compare-And-Swap），CAS是无锁队列的核心

``` shell
CAS(addr, old, new):
    如果 *addr == old:
        *addr = new
        返回 true
    否则:
        返回 false
```

1. slot（槽位）不可重叠写

不同线程必须写不同的数组位置（环形缓冲区常用）

因此要做到：

	•	通过 CAS 抢到自己独立的索引（比如 tail 或 head）
	•	抢到后才进行写或者读

2. 两阶段写模式

典型流程：
```
抢位置（CAS 改 tail）
写入数据（对自己独有的槽写）
发布写入结果（更新某个可见状态）
```
这保证多线程不会互相覆盖数据。

3. 避免假满/假空

环形队列需要对 head 和 tail 使用“留一格”的约定：
```
(tail + 1) % capacity == head → 队列满
tail == head → 队列空
```
这避免了满和空的歧义。

## 示例

```cpp
#include <atomic>  
#include <stdexcept>  
  
template <typename T>  
class LockFreeArrayQueue {  
private:  
    T* buffer;  
    std::atomic<size_t> head, tail;  
    const size_t capacity;  
  
public:  
    LockFreeArrayQueue(size_t capacity)  
        : buffer(new T[capacity]), head(0), tail(0), capacity(capacity) {}  
  
    ~LockFreeArrayQueue() {  
        delete[] buffer;  
    }  
  
    bool enqueue(T item) {  
        size_t newTail = (tail.load() + 1) % capacity;  
        if (newTail == head.load()) {  
            // 队列满  
            return false;  
        }  
        while (true) {  
            size_t currTail = tail.load();  
            if (currTail == newTail) {  
                // 队列满，或tail被其他线程更新  
                continue;  
            }  
            if (tail.compare_exchange_weak(currTail, newTail)) {  
                buffer[currTail] = item;  
                return true;  
            }  
            // CAS失败，重试  
        }  
    }  
  
    bool dequeue(T& item) {  
        if (head.load() == tail.load()) {  
            // 队列空  
            return false;  
        }  
        while (true) {  
            size_t currHead = head.load();  
            size_t newHead = (currHead + 1) % capacity;  
            if (currHead == tail.load()) {  
                // 队列空，或head被其他线程更新  
                continue;  
            }  
            if (head.compare_exchange_weak(currHead, newHead)) {  
                item = buffer[currHead];  
                return true;  
            }  
            // CAS失败，重试  
        }  
    }  
};
```