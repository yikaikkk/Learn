# Java 动态代理
最近重新打算看一下Spring的原理，在看到AOP的时候又看到动态代理。
所以复习一下Java的动态代理。在Java中存在两种代理方式

## JDK代理
### JDK代理原理
JDK的动态代理是基于反射实现。JDK代理需要有一个接口。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类。这就是JDK动态代理大致的实现方式。

### 实例
``` java
public interface CommonService {
    Object query(Long id);

    void delete(Long id);
}

public class UserService implements CommonService {
    @Override
    public Object query(Long id) {
        String s = "查询到用户：" + id;
        System.out.println(s);
        return s;
    }

    @Override
    public void delete(Long id) {
        System.out.println("已删除用户：" + id);
    }
}

public class ProductService implements CommonService {
    @Override
    public Object query(Long id) {
        String s = "查询到商品：" + id;
        System.out.println(s);
        return s;
    }

    @Override
    public void delete(Long id) {
        System.out.println("已删除商品：" + id);
    }
}



import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class LogHandler implements InvocationHandler {
    // 目标对象
    private Object target;

    public LogHandler(Object target) {
        this.target = target;
    }

    private void preHandle() {
        System.out.println("开始处理请求时间: " + System.currentTimeMillis());
    }

    private void postHandle() {
        System.out.println("结束处理请求时间: " + System.currentTimeMillis());
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 请求处理前 记录日志
        preHandle();
        // 目标对象的业务处理逻辑
        Object result = method.invoke(target, args);
        // 请求处理完成 记录日志
        postHandle();
        return result;
    }
}


public static void main(String[] args) {
    /**
     * @see sun.misc.ProxyGenerator#saveGeneratedFiles
     * jdk1.8加上这样的配置(其他版本应当取找sun.misc.ProxyGenerator#saveGeneratedFiles用的是什么)
     * 会将运行时生成的代理Class落磁盘，方便我们查看动态代理生成的class文件。jdk1.8应该是在当前项目根目录的com/sun/proxy目录
     * 注意：在main方法中加该配置
     */
    System.setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");

    // 原对象
    CommonService userService = new UserService();
    CommonService productService = new ProductService();

    // 代理对象
    CommonService proxyUserService = (CommonService) Proxy.newProxyInstance(
            CommonService.class.getClassLoader(),
            new Class[]{CommonService.class},
            new LogHandler(userService));

    CommonService proxyProductService = (CommonService) Proxy.newProxyInstance(
            CommonService.class.getClassLoader(),
            new Class[]{CommonService.class},
            new LogHandler(productService));

    // 测试代理是否生效
    proxyUserService.query(1L);
    System.out.println("----------");
    proxyUserService.delete(1L);

    System.out.println("\n");

    proxyProductService.query(1L);
    System.out.println("----------");
    proxyProductService.delete(1L);
}
```
上述代码的关键是Proxy.newProxyInstance()方法，该方法会根据指定的参数动态创建代理对象。三个参数的意义如下：

loader，指定代理对象的类加载器；
interfaces，代理对象需要实现的接口，可以同时指定多个接口；
handler，方法调用的实际处理者，代理对象的方法调用都会转发到这里（*注意1）。
newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。理解上述代码需要对Java反射机制有一定了解。动态代理神奇的地方就是：

代理对象是在程序运行时产生的，而不是编译期；
对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法，在invoke()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了Hello对象的相应方法，还可以通过RPC调用远程方法。
注意1：对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发。详见JDK Proxy官方文档。

## CGLIB
### 原理
CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。
动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。

### 实例
``` java
public class HelloConcrete {
	public String sayHello(String str) {
		return "HelloConcrete: " + str;
	}
}

// CGLIB动态代理
// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。
class MyMethodInterceptor implements MethodInterceptor{
  ...
	@Override
	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
		logger.info("You said: " + Arrays.toString(args));
		return proxy.invokeSuper(obj, args);
	}
}
// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(HelloConcrete.class);
enhancer.setCallback(new MyMethodInterceptor());

HelloConcrete hello = (HelloConcrete)enhancer.create();
System.out.println(hello.sayHello("I love you!"));


```
上述代码中，我们通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。

注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理。
